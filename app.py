import flask as fl
import json
import os

app = fl.Flask(__name__)
app.secret_key = "dev-secret-key"  # needed for session management
userClasses = {}
classPath = "user_classes.json"
gearPath = "gear_items.json"

name = "TEMP_USER"

@app.route('/login', methods=['GET', 'POST'])
def login():
    if fl.request.method == 'POST':
        if 'submit' in fl.request.form:
            username = fl.request.form.get("username")
            password = fl.request.form.get("password")
            
            if username:
                fl.session['username'] = username
                return fl.redirect(fl.url_for('dashboard'))

    return fl.render_template('login.html')

@app.route('/', methods=['GET'])
def home():
    # Always send first-time visitors to the login page
    return fl.redirect(fl.url_for('login'))


@app.route('/dashboard', methods=['GET'])
def dashboard():
    username = fl.session.get('username')

    # If no one is logged in, send user to login page
    if not username:
        return fl.redirect(fl.url_for('login'))

    # Otherwise render dashboard
    return fl.render_template('dashboard.html', person=username)


@app.route('/create_class', methods=['GET', 'POST'])
def createClass():
    # posts
    if fl.request.method == 'POST':
        # create class submit, check if class name already exists
        if 'submit' in fl.request.form and fl.request.form.get("class_name") not in userClasses:
            print("Creating class...")
            print(fl.request.form)

            # write to json
            with open(classPath, 'w') as file:
                className = fl.request.form.get("class_name")
                userClasses[className] = {"fields": []}
                
                # Parse dynamic fields from form data
                # Fields are named as fields[0][name], fields[0][type], fields[1][name], etc.
                field_indices = set()
                field_names = set()
                for key in fl.request.form:
                    if key.startswith("fields["):
                        # Extract the index from keys like "fields[0][name]"
                        index_str = key.split("[")[1].split("]")[0]
                        field_indices.add(int(index_str))

                        # Check for duplicate field names
                        if key.endswith("[name]"):
                            field_name = fl.request.form.get(key)
                            if field_name in field_names:
                                print(f"Duplicate field name detected: {field_name}")
                                return fl.redirect(fl.url_for('createClass'))
                            field_names.add(field_name)
                
                # Add default ID field
                field = {
                        "name": "ID",
                        "type": "number"
                    }
                userClasses[className]["fields"].append(field)

                # Build fields array in order
                for i in sorted(field_indices):
                    field_name_key = f"fields[{i}][name]"
                    field_type_key = f"fields[{i}][type]"

                    # Add user-defined fields
                    if field_name_key in fl.request.form and field_type_key in fl.request.form:
                        field = {
                            "name": fl.request.form.get(field_name_key),
                            "type": fl.request.form.get(field_type_key)
                        }
                        userClasses[className]["fields"].append(field)
                    
                json.dump(userClasses, file, indent=4)
                print(f"Successfully created class '{className}' with {len(userClasses[className]['fields'])} fields")
        else:
            print("Class name already exists or no name provided.")
    
    #template
    return fl.render_template('create_class.html')


@app.route('/add_gear', methods=['GET', 'POST'])
def addGear():
    # load existing gear items
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    if fl.request.method == 'POST':
        className = fl.request.form.get('class_name')
        if not className or className not in userClasses:
            print('Invalid class selected')
            return fl.redirect(fl.url_for('addGear'))

        # ensure class list exists
        if className not in gearItems:
            gearItems[className] = []

        fields = userClasses[className].get('fields', [])
        item = {}
        provided_id = None

        # Read values based on indices generated by template
        for i, field in enumerate(fields):
            name_key = f'fieldname_{i}'
            val_key = f'field_{i}'
            field_name = fl.request.form.get(name_key)

            # booleans are checkboxes, present only when checked
            if field.get('type') == 'boolean':
                value = True if fl.request.form.get(val_key) else False
            else:
                value = fl.request.form.get(val_key)

            # convert numbers when possible
            if field.get('type') == 'number' and value is not None and value != '':
                try:
                    if '.' in value:
                        value = float(value)
                    else:
                        value = int(value)
                except Exception:
                    pass

            item[field_name] = value
            if field_name == 'ID' and value not in (None, ''):
                provided_id = value

        # assign ID if not provided by user
        if provided_id:
            # Check if ID already exists
            existing_ids = [it.get('ID') for it in gearItems.get(className, [])]
            if provided_id in existing_ids or str(provided_id) in [str(x) for x in existing_ids]:
                print(f"Item with ID {provided_id} already exists in {className}")
                return fl.redirect(fl.url_for('addGear'))
            item_id = provided_id
            item['ID'] = item_id
        else:
            existing_ids = [it.get('ID') for it in gearItems.get(className, []) if it.get('ID') is not None]
            try:
                maxid = max([int(x) for x in existing_ids]) if existing_ids else 0
            except Exception:
                maxid = 0
            item_id = maxid + 1
            item['ID'] = item_id

        gearItems[className].append(item)

        with open(gearPath, 'w') as f:
            json.dump(gearItems, f, indent=4)

        print(f"Added item to {className}: {item}")
        return fl.redirect(fl.url_for('dashboard'))

    # GET -> render form
    return fl.render_template('add_gear.html', userClasses=userClasses)


@app.route('/edit_gear', methods=['GET', 'POST'])
def editGear():
    # load existing gear items
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    if fl.request.method == 'POST':
        className = fl.request.form.get('class_name')
        item_id = fl.request.form.get('item_id')
        
        if not className or className not in userClasses or className not in gearItems:
            print('Invalid class selected')
            return fl.redirect(fl.url_for('editGear'))

        # Find the item to edit
        item_index = None
        for idx, item in enumerate(gearItems[className]):
            if str(item.get('ID')) == str(item_id):
                item_index = idx
                break
        
        if item_index is None:
            print('Item not found')
            return fl.redirect(fl.url_for('editGear'))

        fields = userClasses[className].get('fields', [])
        updated_item = {}

        # Read updated values from form
        for i, field in enumerate(fields):
            name_key = f'fieldname_{i}'
            val_key = f'field_{i}'
            field_name = fl.request.form.get(name_key)

            # booleans are checkboxes, present only when checked
            if field.get('type') == 'boolean':
                value = True if fl.request.form.get(val_key) else False
            else:
                value = fl.request.form.get(val_key)

            # convert numbers when possible
            if field.get('type') == 'number' and value is not None and value != '':
                try:
                    if '.' in value:
                        value = float(value)
                    else:
                        value = int(value)
                except Exception:
                    pass

            updated_item[field_name] = value

        # Update the item in the list
        gearItems[className][item_index] = updated_item

        with open(gearPath, 'w') as f:
            json.dump(gearItems, f, indent=4)

        print(f"Updated item {item_id} in {className}: {updated_item}")
        return fl.redirect(fl.url_for('dashboard'))

    # GET -> render form
    return fl.render_template('edit_gear.html', userClasses=userClasses, gearItems=gearItems)


@app.route('/search_gear', methods=['GET', 'POST'])
def searchGear():
    # Always re-read so searches include the latest changes
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    query = ''
    results = []

    if fl.request.method == 'POST':
        query = (fl.request.form.get('query') or '').strip().lower()
        for cname, items in gearItems.items():
            for item in items:
                # Match if the term shows up in any value
                if not query or any(query in str(val).lower() for val in item.values()):
                    results.append({"class": cname, "item": item})

    return fl.render_template('search_gear.html', results=results, query=query)


@app.route('/delete_gear', methods=['GET', 'POST'])
def deleteGear():
    # Fresh read keeps deletes in sync with what the user just saw
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    if fl.request.method == 'POST':
        className = fl.request.form.get('class_name')
        item_id = fl.request.form.get('item_id')

        if className and item_id and className in gearItems:
            items = gearItems.get(className, [])
            # Drop the requested ID if it exists
            new_items = [it for it in items if str(it.get('ID')) != str(item_id)]

            if len(new_items) != len(items):
                # Only write when something actually changed
                gearItems[className] = new_items
                with open(gearPath, 'w') as f:
                    json.dump(gearItems, f, indent=4)
                print(f"Deleted item {item_id} from {className}")
                return fl.redirect(fl.url_for('dashboard'))

        print('Invalid delete request')
        return fl.redirect(fl.url_for('deleteGear'))

    return fl.render_template('delete_gear.html')


@app.route('/checkout_gear', methods=['GET', 'POST'])
def checkoutGear():
    # Pull the latest data before deciding if something is available
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    if fl.request.method == 'POST':
        className = fl.request.form.get('class_name')
        item_id = fl.request.form.get('item_id')
        borrower = fl.request.form.get('borrower') or 'Unknown'
        due_date = fl.request.form.get('due_date') or ''

        # Need class, id, and a record of who took it
        if className and item_id and className in gearItems:
            for item in gearItems.get(className, []):
                if str(item.get('ID')) == str(item_id):
                    # Stop double-booking
                    if item.get('is_checked_out'):
                        print('Item already checked out')
                        return fl.redirect(fl.url_for('checkoutGear'))

                    # Mark that this item is out and who has it
                    item['is_checked_out'] = True
                    item['checked_out_by'] = borrower
                    item['due_date'] = due_date

                    # Persist the update
                    with open(gearPath, 'w') as f:
                        json.dump(gearItems, f, indent=4)

                    print(f"Checked out item {item_id} in {className} to {borrower}")
                    return fl.redirect(fl.url_for('dashboard'))

        print('Invalid checkout request')
        return fl.redirect(fl.url_for('checkoutGear'))

    return fl.render_template('checkout_gear.html')

@app.route('/view_gear', methods=['GET'])
def view_gear():
    # Load gear items from file
    if os.path.exists(gearPath) and os.path.getsize(gearPath) > 0:
        with open(gearPath, 'r') as f:
            gearItems = json.load(f)
    else:
        gearItems = {}

    # gearItems is expected to be: { "ClassName": [ {item1}, {item2}, ... ], ... }
    return fl.render_template('view_gear.html', gearItems=gearItems)
    

if __name__ == '__main__':
   # load user classes if file exists
    if os.path.exists(classPath) and os.path.getsize(classPath) > 0:
        with open(classPath, 'r') as file:
           userClasses = json.load(file)
    else:
        userClasses = {}

    # run app
    app.run(debug = True)